<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.120.4"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="MRFramework"><meta itemprop=description content="保持简单的易用性和强大的功能。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=keywords content><meta property="og:type" content="article"><meta property="og:title" content="MRFramework"><meta property="og:description" content="保持简单的易用性和强大的功能。"><meta property="og:image" content="/imgs/hugo_next_avatar.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/mrframework/mrframework/"><meta property="og:site_name" content="满床清梦压星河"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="醉雨非烟"><meta property="article:published_time" content="2023-12-04 17:28:02 +0800 CST"><meta property="article:modified_time" content="2023-12-04 17:28:02 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.c6314ee35c2ca6a83715ea832b49947b0615fd8fc1eea0602e380c0b968fba5e.css><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"mrframework","permalink":"/post/mrframework/mrframework/","title":"MRFramework","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>MRFramework - 满床清梦压星河</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>满床清梦压星河</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>欢迎来到我的博客~</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>分类</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>6</span></a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#快速开始>快速开始</a></li><li><a href=#框架基本使用>框架基本使用</a><ul><li><a href=#1-mvc-的实现>1. MVC 的实现</a></li><li><a href=#2-引入-command>2. 引入 Command</a></li><li><a href=#3-引入-event>3. 引入 Event</a></li><li><a href=#4-引入-utility>4. 引入 Utility</a></li><li><a href=#5-引入-system>5. 引入 System</a></li><li><a href=#6-使用-bindableproperty-优化事件>6. 使用 BindableProperty 优化事件</a><ul><li><a href=#61-bindableproperty-基本使用>6.1 BindableProperty 基本使用</a></li><li><a href=#62-使用-bindableproperty-优化-counterapp-的代码>6.2 使用 BindableProperty 优化 CounterApp 的代码</a></li></ul></li><li><a href=#7-最后全部示例代码>7. 最后全部示例代码</a><ul><li><a href=#71-用接口设计模块依赖倒置原则>7.1 用接口设计模块（依赖倒置原则）</a></li><li><a href=#72-接口设计模块的好处>7.2 接口设计模块的好处</a></li></ul></li></ul></li><li><a href=#框架工具>框架工具</a><ul><li><a href=#1-单例模式singleton>1. 单例模式（Singleton）</a></li><li><a href=#2-事件系统event>2. 事件系统（Event）</a><ul><li><a href=#21-基础用法>2.1 基础用法</a></li><li><a href=#22-如果需要手动注销事件>2.2 如果需要手动注销事件</a></li><li><a href=#23-简易事件系统easyevent>2.3 简易事件系统（EasyEvent）</a></li></ul></li><li><a href=#3-对象池pool>3. 对象池（Pool）</a><ul><li><a href=#31-object-对象池>3.1 Object 对象池</a></li><li><a href=#32-gameobject-对象池>3.2 GameObject 对象池</a></li><li><a href=#33-对象池销毁>3.3 对象池销毁</a></li></ul></li><li><a href=#4-计时器timer>4. 计时器（Timer）</a></li><li><a href=#5-音效系统audio>5. 音效系统（Audio）</a></li><li><a href=#6-公共的-monobehaviourmono>6. 公共的 MonoBehaviour（Mono）</a><ul><li><a href=#61-帧更新事件>6.1 帧更新事件</a></li><li><a href=#62-让普通类能使用协程>6.2 让普通类能使用协程</a></li><li><a href=#63-mono-常用方法>6.3 Mono 常用方法</a></li></ul></li><li><a href=#7-资源加载工具集resloadkit>7. 资源加载工具集（ResLoadKit）</a><ul><li><a href=#71-启动资源加载管理器工具集>7.1 启动资源加载管理器工具集</a></li><li><a href=#72-同步加载资源>7.2 同步加载资源</a></li><li><a href=#72-异步加载资源>7.2 异步加载资源</a></li><li><a href=#73-加载gameobjec对象自动实例化>7.3 加载GameObjec对象，自动实例化</a></li><li><a href=#73-资源释放>7.3 资源释放</a></li></ul></li><li><a href=#8-数据存储datakit>8. 数据存储（DataKit）</a><ul><li><a href=#81-playerprefs>8.1 PlayerPrefs</a></li><li><a href=#82-json>8.2 Json</a></li></ul></li><li><a href=#9-有限状态机fsm>9. 有限状态机（FSM）</a><ul><li><a href=#91-链式>9.1 链式</a></li><li><a href=#92-类模式>9.2 类模式</a></li></ul></li><li><a href=#10-ui-界面管理uikit>10. UI 界面管理（UIKit）</a><ul><li><a href=#101-ui-代码自动生成>10.1 UI 代码自动生成</a></li><li><a href=#102-ui-面板管理>10.2 UI 面板管理</a></li><li><a href=#103-ui-面板的生命周期自带方法>10.3 UI 面板的生命周期、自带方法</a></li></ul></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=醉雨非烟 src=/imgs/img-lazy-loading.gif data-src=/imgs/hugo_next_avatar.png><p class=site-author-name itemprop=name>醉雨非烟</p><div class=site-description itemprop=description>保持简单的易用性和强大的功能。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>6</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>3</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>0</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/elkan1788 title="Github → https://github.com/elkan1788" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github
</a></span><span class=links-of-social-item><a href=https://www.zhihu.com/people/lisenhui title="Bilibili → https://www.zhihu.com/people/lisenhui" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa-brands fa-bilibili fa-fw hvr-icon"></i>
Bilibili</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2023-12-04T17:28:02+08:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=10255></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=24></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2023-12-05T21:31:40+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-gtranslate class=button title=多语言翻译><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script><script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/mrframework/mrframework/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=name content="醉雨非烟"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="醉雨非烟"><meta itemprop=description content="保持简单的易用性和强大的功能。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="MRFramework"><meta itemprop=description content="这是一个轻量级的 Unity 框架，能帮助你进行快速的游戏开发。"></span><header class=post-header><h1 class=post-title itemprop="name headline"><span class=post-sticky-flag title=置顶><i class="fa fa-thumbtack"></i>
</span>MRFramework
<a href=https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name/post/MRFramework/MRFramework.md rel="noopener external nofollow noreferrer" target=_blank class="exturl post-edit-link" title=编辑><i class="fa fa-pen-nib"></i></a></h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2023-12-04 17:28:02 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-12-04 17:28:02 +0800 CST">2023-12-04
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/unity-%E6%A1%86%E6%9E%B6 itemprop=url rel=index><span itemprop=name>Unity 框架</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>7016</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>15分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=busuanzi_value_page_pv data-path=/post/mrframework/mrframework/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>这是一个轻量级的 Unity 框架，能帮助你进行快速的游戏开发。</p><h2 id=快速开始>快速开始
<a class=header-anchor href=#%e5%bf%ab%e9%80%9f%e5%bc%80%e5%a7%8b></a></h2><p>（1）项目导入 Addressables 。</p><p>（2）导入 MRFramework。</p><p>文件信息：</p><ul><li>MRFramework 框架</li><li>MRFrameworkExample 框架示例（可选导入）</li></ul><h2 id=框架基本使用>框架基本使用
<a class=header-anchor href=#%e6%a1%86%e6%9e%b6%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8></a></h2><h3 id=1-mvc-的实现>1. MVC 的实现
<a class=header-anchor href=#1-mvc-%e7%9a%84%e5%ae%9e%e7%8e%b0></a></h3><p>（1）定义一个架构（提供 MVC、分层、模块管理等）</p><p>Architecture 用于管理模块，或者说 Architecture 提供一整套架构的解决方案，而模块管理和提供 MVC 只是其功能的一小部分。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CounterApp</span> : Architecture&lt;CounterApp&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Init()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 注册 Model</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.RegisterModel(<span style=color:#66d9ef>new</span> CounterAppModel());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>（2）定义一个 Model 对象</p><p>Model 的引入是为了解决数据共享的问题，而不是说单只是为了让数据和表现分离，这一点是非常重要的一点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CounterAppModel</span> : AbstractModel
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Count;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnInit()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Count = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>（3）Controller 逻辑</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>/* 实现 IController 接口 */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CounterAppController</span> : MonoBehaviour , IController
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// View</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Button BtnAdd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Button BtnSub;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Text TxtCount;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Model</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> CounterAppModel model;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取 Model</span>
</span></span><span style=display:flex><span>        model = <span style=color:#66d9ef>this</span>.GetModel&lt;CounterAppModel&gt;();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 监听输入</span>
</span></span><span style=display:flex><span>        BtnAdd.onClick.AddListener(() =&gt;
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 交互逻辑</span>
</span></span><span style=display:flex><span>            model.Count++;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 表现逻辑</span>
</span></span><span style=display:flex><span>            UpdateView();        
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        BtnSub.onClick.AddListener(() =&gt;
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 交互逻辑</span>
</span></span><span style=display:flex><span>            model.Count--;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 表现逻辑</span>
</span></span><span style=display:flex><span>            UpdateView();
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 更新面板信息</span>
</span></span><span style=display:flex><span>        UpdateView();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> UpdateView()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        TxtCount.text = model.Count.ToString();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 指定架构</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> IArchitecture GetArchitecture()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> CounterApp.Interface;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将 Model 设置为空</span>
</span></span><span style=display:flex><span>        model = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-引入-command>2. 引入 Command
<a class=header-anchor href=#2-%e5%bc%95%e5%85%a5-command></a></h3><p>现在，数据共享的问题通过引入 Model 解决了。这里再次强调一下，需要共享的数据放 Model 里，不需要共享的，能不放就不放。</p><p>虽然引入了 Model，但是这套代码随着项目规模的发展还是有很多的问题。其中最严重也最常见的就是 Controller 会越来越臃肿。</p><p>我们简单分析一下为什么 Controller 会越来越臃肿，我们先看下监听用户输入部分的代码，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// 监听输入</span>
</span></span><span style=display:flex><span>mBtnAdd.onClick.AddListener(() =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 交互逻辑</span>
</span></span><span style=display:flex><span>    mModel.Count++;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 表现逻辑</span>
</span></span><span style=display:flex><span>    UpdateView();        
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>mBtnSub.onClick.AddListener(() =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 交互逻辑</span>
</span></span><span style=display:flex><span>    mModel.Count--;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 表现逻辑</span>
</span></span><span style=display:flex><span>    UpdateView();
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>Controller 本身之所以臃肿，是因为，它负责了两种职责，即改变 Model 数据 的交互逻辑，以及 Model 数据变更之后更新到界面的表现逻辑。</p><p>在一个有一定规模的项目中，表现逻辑和交互逻辑非常多。而一个 Controller 很容易就做到上千行代码。</p><p>而大部分的 MVC 方案，解决 Controller 臃肿用的是引入 Command 的方式，即引入命令模式，通过命令来分担 Controller 的交互逻辑的职责。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// 引入 Command</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>IncreaseCountCommand</span> : AbstractCommand <span style=color:#75715e>// ++</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnExecute()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.GetModel&lt;CounterAppModel&gt;().Count++;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DecreaseCountCommand</span> : AbstractCommand <span style=color:#75715e>// ++</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnExecute()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.GetModel&lt;CounterAppModel&gt;().Count--;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>修改 Controller 逻辑：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span>mBtnAdd.onClick.AddListener(() =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 交互逻辑</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.SendCommand&lt;IncreaseCountCommand&gt;();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 表现逻辑</span>
</span></span><span style=display:flex><span>    UpdateView();        
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mBtnSub.onClick.AddListener(() =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 交互逻辑</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.SendCommand&lt;DecreaseCountCommand&gt;();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 表现逻辑</span>
</span></span><span style=display:flex><span>    UpdateView();
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>使用 Command 可以带来很多便利，比如：</p><ul><li>Command 可以复用，Command 也可以调用 Command</li><li>Command 可以比较方便实现撤销功能，如果 App 或者 游戏需要的话</li><li>如果遵循一定规范，可以实现使用 Command 跑自动化测试。</li><li>Command 可以定制 Command 队列，也可以让 Command 按照特定的方式执行</li><li>一个 Command 也可以封装成一个 Http 或者 TCP 里的一次数据请求</li><li>Command 可以实现 Command 中间件模式</li></ul><p>Command 最明显的好处就是：</p><ul><li>就算代码再乱，也只是在一个 Command 对象里乱，而不会影响其他的对象。</li><li>将方法封装成命令对象，可以实现对命令对象的组织、排序、延时等操作。</li></ul><h3 id=3-引入-event>3. 引入 Event
<a class=header-anchor href=#3-%e5%bc%95%e5%85%a5-event></a></h3><p>我们通过引入了 Command 来帮助 Controller 分担了一部分的交互逻辑。但是表现逻辑的代码目前看起来并不是很智能。</p><p>每次调用逻辑之后，表现逻辑部分都需要手动调用一次（UpdateView 方法）。</p><p>现在表现逻辑的代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 监听输入</span>
</span></span><span style=display:flex><span>mBtnAdd.onClick.AddListener(() =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 交互逻辑</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.SendCommand&lt;IncreaseCountCommand&gt;();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 表现逻辑</span>
</span></span><span style=display:flex><span>    UpdateView();        
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>mBtnSub.onClick.AddListener(() =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 交互逻辑</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.SendCommand&lt;DecreaseCountCommand&gt;();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 表现逻辑</span>
</span></span><span style=display:flex><span>    UpdateView();
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>（1）引入 Event：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 定义结构体事件，需要继承 IEventData</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 最好是传入结构体，因为结构体比类的性能消耗要小</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CountChangeEvent</span> : IEventData
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>（2）Command 触发事件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>IncreaseCountCommand</span> : AbstractCommand 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnExecute()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.GetModel&lt;CounterAppModel&gt;().Count++;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 触发事件</span>
</span></span><span style=display:flex><span>	    EventManager.Instance.Trigger&lt;CountChangeEvent&gt;();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DecreaseCountCommand</span> : AbstractCommand
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnExecute()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.GetModel&lt;CounterAppModel&gt;().Count--;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 触发事件</span>
</span></span><span style=display:flex><span>	    EventManager.Instance.Trigger&lt;CountChangeEvent&gt;();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>（3）Controller 修改：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 监听输入</span>
</span></span><span style=display:flex><span>BtnAdd.onClick.AddListener(() =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 交互逻辑</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.SendCommand&lt;IncreaseCountCommand&gt;();
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>BtnSub.onClick.AddListener(() =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 交互逻辑</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.SendCommand(<span style=color:#66d9ef>new</span> DecreaseCountCommand(<span style=color:#75715e>/* 这里可以传参（如果有） */</span>));
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 注册事件</span>
</span></span><span style=display:flex><span>EventManager.Instance.Register&lt;CountChangeEvent&gt;((eventData) =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 更新面板数据</span>
</span></span><span style=display:flex><span>    UpdateView();
</span></span><span style=display:flex><span>}).UnRegisterWhenGameObjectDestroyed(<span style=color:#66d9ef>this</span>); <span style=color:#75715e>// 自动注销事件</span>
</span></span></code></pre></div><h3 id=4-引入-utility>4. 引入 Utility
<a class=header-anchor href=#4-%e5%bc%95%e5%85%a5-utility></a></h3><p>在这一篇，我们来支持 CounterApp 的存储功能。</p><p>其代码也非常简单，只需要修改一部分 Model 的代码即可，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 定义一个 Model 对象</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CounterAppModel</span> : AbstractModel
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> count;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Count
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span> =&gt; count;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>set</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 存储</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (count != <span style=color:#66d9ef>value</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                count = <span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>                PlayerPrefs.SetInt(nameof(count), count);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 读取</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnInit()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        count = PlayerPrefs.GetInt(nameof(count), count);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样就支持了非常基本的数据存储功能。</p><p>当然还是有一些问题，如果时候未来我们需要存储的数据非常多的时候，Model 层就会充斥大量存储、加载相关的代码。</p><p>还有就是，我们以后如果不想使用 PlayperPrefs 了，想使用 EasySave 或者 SQLite 的时候，就会造成大量的修改工作量。</p><p>于是提供了一个 Utility 层，专门用来解决上述两个问题的，使用方法非常简单，如下：</p><p>（1）定义一个 Utility</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StorageUtility</span> : IUtility
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> SavaInt(<span style=color:#66d9ef>string</span> key, <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>value</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        PlayerPrefs.SetInt(key, <span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> LoadInt(<span style=color:#66d9ef>string</span> key, <span style=color:#66d9ef>int</span> defaultValue = <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> PlayerPrefs.GetInt(key, defaultValue);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>（2）注册存储工具对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 定义一个架构（提供 MVC、分层、模块管理等）</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CounterApp</span> : Architecture&lt;CounterApp&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 注册 Model</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.RegisterModel(<span style=color:#66d9ef>new</span> CounterAppModel());
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 注册存储工具的对象</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.RegisterUtility(<span style=color:#66d9ef>new</span> StorageUtility());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>（3）在 Model 层中使用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 定义一个 Model 对象</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CounterAppModel</span> : AbstractModel
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Count;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> StorageUtility storage;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnInit()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        storage = <span style=color:#66d9ef>this</span>.GetUtility&lt;StorageUtility&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 读取数据</span>
</span></span><span style=display:flex><span>        Count = storage.LoadInt(nameof(Count));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 可以通过 事件系统 监听数据变更事件</span>
</span></span><span style=display:flex><span>        EventManager.Instance.Register&lt;CountChangeEvent&gt;(SaveIntEvent);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> SaveIntEvent(IEventData eventData)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        storage.SaveInt(nameof(Count), Count);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 由于事件系统的自动注销仅支持继承了 Mono 的类</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 需要手动来注销事件</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        EventManager.Instance.UnRegister&lt;CountChangeEvent&gt;(SaveIntEvent);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>（4）在 Controller 中手动注销事件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将 Model 设置为空</span>
</span></span><span style=display:flex><span>    model.OnDestroy();
</span></span><span style=display:flex><span>    model = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=5-引入-system>5. 引入 System
<a class=header-anchor href=#5-%e5%bc%95%e5%85%a5-system></a></h3><p>假设要添加一个成就达成的功能，即 Count 到 10 的时候，触发一个点击达人成就，点击二十次则触发一个点击专家成就。</p><p>逻辑听起来很简单，我们直接在 IncreaseCountCommand 里编写即可，如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 引入 Command</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>IncreaseCountCommand</span> : AbstractCommand <span style=color:#75715e>// ++</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> CounterAppModel model;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnExecute()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        model = <span style=color:#66d9ef>this</span>.GetModel&lt;CounterAppModel&gt;();
</span></span><span style=display:flex><span>        model.Count++;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 触发事件</span>
</span></span><span style=display:flex><span>        EventManager.Instance.Trigger&lt;CountChangeEvent&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(model.Count == <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Debug.Log(<span style=color:#e6db74>&#34;触发 点击达人 成就&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (model.Count == <span style=color:#ae81ff>20</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Debug.Log(<span style=color:#e6db74>&#34;触发 点击专家 成就&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>但是这个时候策划说，希望再增加一个当点击 - 号到 -10 时，触发一个 点击菜鸟成就，然后策划还说，点击达人 和 点击专家 成就太容易达成了，需要分别改成 1000 次 和 2000 次。</p><p>而这次策划提出的需求，需要我们修改两处的代码，即 IncreaseCountCommand 里需要修改数值为 1000 和 2000，然后再 DecreaseCountCommand 增加一个判断逻辑。</p><p>一次提出的需求，结果造成了多处修改，这说明代码有问题。</p><p>首先像这种规则类的逻辑，比如分数统计或者成就统计等代码，不适合分散写在 Command 里，而适合统一写在一个对象里，而这种对象，在 MRFramework 里有提供，就是 System 对象。</p><p>（1）定义一个 System</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 成就系统</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AchievementSystem</span> : AbstractSystem
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> CounterAppModel model;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnInit()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        model = <span style=color:#66d9ef>this</span>.GetModel&lt;CounterAppModel&gt;();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 通过事件来触发</span>
</span></span><span style=display:flex><span>        EventManager.Instance.Register&lt;CountChangeEvent&gt;(AchievementEvent);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> AchievementEvent(IEventData eventData)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (model.Count == <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Debug.Log(<span style=color:#e6db74>&#34;触发 点击达人 成就&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (model.Count == <span style=color:#ae81ff>20</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Debug.Log(<span style=color:#e6db74>&#34;触发 点击专家 成就&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (model.Count == -<span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Debug.Log(<span style=color:#e6db74>&#34;触发 点击菜鸟 成就&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 由于事件系统的自动注销仅支持继承了 Mono 的类</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 需要手动来注销事件</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        EventManager.Instance.UnRegister&lt;CountChangeEvent&gt;(AchievementEvent);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>（2）把 Command 修改还原，将成就系统注册进架构</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 定义一个架构（提供 MVC、分层、模块管理等）</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CounterApp</span> : Architecture&lt;CounterApp&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 注册 System </span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.RegisterSystem(<span style=color:#66d9ef>new</span> AchievementSystem());
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 注册 Model</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.RegisterModel(<span style=color:#66d9ef>new</span> CounterAppModel());
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 注册存储工具的对象</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.RegisterUtility(<span style=color:#66d9ef>new</span> StorageUtility());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>（3）在 Controller 中手动注销事件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将 Model 设置为空</span>
</span></span><span style=display:flex><span>    model.OnDestroy();
</span></span><span style=display:flex><span>    model = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.GetSystem&lt;AchievementSystem&gt;().OnDestroy();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=6-使用-bindableproperty-优化事件>6. 使用 BindableProperty 优化事件
<a class=header-anchor href=#6-%e4%bd%bf%e7%94%a8-bindableproperty-%e4%bc%98%e5%8c%96%e4%ba%8b%e4%bb%b6></a></h3><h4 id=61-bindableproperty-基本使用>6.1 BindableProperty 基本使用
<a class=header-anchor href=#61-bindableproperty-%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8></a></h4><p>BindableProperty 是包含 数据 + 数据变更事件 的一个对象。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>private</span> BindableProperty&lt;<span style=color:#66d9ef>int</span>&gt; age = <span style=color:#66d9ef>new</span> BindableProperty&lt;<span style=color:#66d9ef>int</span>&gt;(<span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    age.Register((newAge) =&gt;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Debug.Log(newAge);
</span></span><span style=display:flex><span>    }).UnRegisterWhenGameObjectDestroyed(gameObject);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    age.Value++;
</span></span><span style=display:flex><span>    age.Value--;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 输出结果</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 11</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 10</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这段代码的逻辑就是当调用 age++ 和 age&ndash; 的时候，就会触发数据变更事件。</p><p>BindableProperty 除了提供 Register 这个 API 之外，还提供了 RegisterWithInitValue API，意思是<strong>注册时先把当前值返回过来</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>private</span> BindableProperty&lt;<span style=color:#66d9ef>int</span>&gt; age = <span style=color:#66d9ef>new</span> BindableProperty&lt;<span style=color:#66d9ef>int</span>&gt;(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    age.RegisterWithInitValue((newAge) =&gt;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Debug.Log(newAge);
</span></span><span style=display:flex><span>    }).UnRegisterWhenGameObjectDestroyed(gameObject);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 输出结果</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 5</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个 API 就是，没有任何变化的情况下，age 先返回一个当前的值，<strong>比较方便用于显示初始界面</strong>。</p><h4 id=62-使用-bindableproperty-优化-counterapp-的代码>6.2 使用 BindableProperty 优化 CounterApp 的代码
<a class=header-anchor href=#62-%e4%bd%bf%e7%94%a8-bindableproperty-%e4%bc%98%e5%8c%96-counterapp-%e7%9a%84%e4%bb%a3%e7%a0%81></a></h4><p>（1）修改 Model</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 定义一个 Model 对象</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CounterAppModel</span> : AbstractModel
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> BindableProperty&lt;<span style=color:#66d9ef>int</span>&gt; Count { <span style=color:#66d9ef>get</span>; } = <span style=color:#66d9ef>new</span> BindableProperty&lt;<span style=color:#66d9ef>int</span>&gt;();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> StorageUtility storage;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnInit()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        storage = <span style=color:#66d9ef>this</span>.GetUtility&lt;StorageUtility&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 设置初始值（不触发事件） 读取数据</span>
</span></span><span style=display:flex><span>        Count.SetValueWithoutEvent(storage.LoadInt(nameof(Count)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 当数据变更时 存储数据</span>
</span></span><span style=display:flex><span>        Count.Register(SaveIntEvent);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> SaveIntEvent(<span style=color:#66d9ef>int</span> newCount)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        storage.SaveInt(nameof(Count), newCount);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 由于事件系统的自动注销仅支持继承了 Mono 的类</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 需要手动来注销事件</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Count.UnRegister(SaveIntEvent);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>（2）修改 System</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 成就系统</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AchievementSystem</span> : AbstractSystem
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> CounterAppModel model;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnInit()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        model = <span style=color:#66d9ef>this</span>.GetModel&lt;CounterAppModel&gt;();
</span></span><span style=display:flex><span>        model.Count.Register(AchievementEvent);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> AchievementEvent(<span style=color:#66d9ef>int</span> newCount)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (model.Count == <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Debug.Log(<span style=color:#e6db74>&#34;触发 点击达人 成就&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (model.Count == <span style=color:#ae81ff>20</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Debug.Log(<span style=color:#e6db74>&#34;触发 点击专家 成就&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (model.Count == -<span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Debug.Log(<span style=color:#e6db74>&#34;触发 点击菜鸟 成就&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 由于事件系统的自动注销仅支持继承了 Mono 的类</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 需要手动来注销事件</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        model.Count.UnRegister(AchievementEvent);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>（3）修改 Command</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 引入 Command</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>IncreaseCountCommand</span> : AbstractCommand <span style=color:#75715e>// ++</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnExecute()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.GetModel&lt;CounterAppModel&gt;().Count.Value++;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DecreaseCountCommand</span> : AbstractCommand <span style=color:#75715e>// ++</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnExecute()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.GetModel&lt;CounterAppModel&gt;().Count.Value--;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>（4）修改 Controller</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取 Model</span>
</span></span><span style=display:flex><span>    model = <span style=color:#66d9ef>this</span>.GetModel&lt;CounterAppModel&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    BtnAdd.onClick.AddListener(() =&gt;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 交互逻辑</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.SendCommand&lt;IncreaseCountCommand&gt;();
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    BtnSub.onClick.AddListener(() =&gt;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 交互逻辑</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.SendCommand(<span style=color:#66d9ef>new</span> DecreaseCountCommand(<span style=color:#75715e>/* 这里可以传参（如果有） */</span>));
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 表现逻辑</span>
</span></span><span style=display:flex><span>    model.Count.RegisterWithInitValue((newCount) =&gt;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        UpdateView();
</span></span><span style=display:flex><span>    }).UnRegisterWhenGameObjectDestroyed(gameObject);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>代码改动很多，重要的改动为：</p><ul><li>Model 中的 Count 改成了一个叫做 Count 的 BindableProperty</li><li>删掉了 CountChangeEvent 事件，改用监听 BindableProperty</li><li>Controller 在初始化中去掉一次 UpdateView 的主动调用，改为 RegisterWithInitValue 设置初始界面。</li></ul><p>可以说代码量一下子少了很多，由于 Count 数据，是单个数据 + 事件变更的形式，所以用 BindableProperty 非常合适，可以少写很多代码。</p><p>一般情况下，像主角的金币、分数等数据非常适合用 BindableProperty 的方式实现。</p><h3 id=7-最后全部示例代码>7. 最后全部示例代码
<a class=header-anchor href=#7-%e6%9c%80%e5%90%8e%e5%85%a8%e9%83%a8%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81></a></h3><h4 id=71-用接口设计模块依赖倒置原则>7.1 用接口设计模块（依赖倒置原则）
<a class=header-anchor href=#71-%e7%94%a8%e6%8e%a5%e5%8f%a3%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%9d%97%e4%be%9d%e8%b5%96%e5%80%92%e7%bd%ae%e5%8e%9f%e5%88%99></a></h4><p>MRFramework 本身支持依赖倒置原则，就是所有的模块访问和交互都可以通过接口来完成，代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine.UI;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> MRFramework.Example
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 定义一个架构（提供 MVC、分层、模块管理等）</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CounterApp</span> : Architecture&lt;CounterApp&gt;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 注册 System </span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.RegisterSystem&lt;IAchievementSystem&gt;(<span style=color:#66d9ef>new</span> AchievementSystem());
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 注册 Model</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.RegisterModel&lt;ICounterAppModel&gt;(<span style=color:#66d9ef>new</span> CounterAppModel());
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 注册存储工具的对象</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.RegisterUtility&lt;IStorage&gt;(<span style=color:#66d9ef>new</span> StorageUtility());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 定义一个 Model 对象</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ICounterAppModel</span> : IModel
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        BindableProperty&lt;<span style=color:#66d9ef>int</span>&gt; Count { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CounterAppModel</span> : AbstractModel, ICounterAppModel
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> BindableProperty&lt;<span style=color:#66d9ef>int</span>&gt; Count { <span style=color:#66d9ef>get</span>; } = <span style=color:#66d9ef>new</span> BindableProperty&lt;<span style=color:#66d9ef>int</span>&gt;();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> StorageUtility storage;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnInit()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            storage = <span style=color:#66d9ef>this</span>.GetUtility&lt;StorageUtility&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 设置初始值（不触发事件） 读取数据</span>
</span></span><span style=display:flex><span>            Count.SetValueWithoutEvent(storage.LoadInt(nameof(Count)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 当数据变更时 存储数据</span>
</span></span><span style=display:flex><span>            Count.Register(SaveIntEvent);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> SaveIntEvent(<span style=color:#66d9ef>int</span> newCount)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            storage.SaveInt(nameof(Count), newCount);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 由于事件系统的自动注销仅支持继承了 Mono 的类</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 需要手动来注销事件</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Count.UnRegister(SaveIntEvent);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 成就系统</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IAchievementSystem</span> : ISystem
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AchievementSystem</span> : AbstractSystem, IAchievementSystem
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> CounterAppModel model;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnInit()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            model = <span style=color:#66d9ef>this</span>.GetModel&lt;CounterAppModel&gt;();
</span></span><span style=display:flex><span>            model.Count.Register(AchievementEvent);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> AchievementEvent(<span style=color:#66d9ef>int</span> newCount)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (model.Count == <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Debug.Log(<span style=color:#e6db74>&#34;触发 点击达人 成就&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (model.Count == <span style=color:#ae81ff>20</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Debug.Log(<span style=color:#e6db74>&#34;触发 点击专家 成就&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (model.Count == -<span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Debug.Log(<span style=color:#e6db74>&#34;触发 点击菜鸟 成就&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 由于事件系统的自动注销仅支持继承了 Mono 的类</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 需要手动来注销事件</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            model.Count.UnRegister(AchievementEvent);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 定义一个 Utility</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IStorage</span> : IUtility
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> SaveInt(<span style=color:#66d9ef>string</span> key, <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> LoadInt(<span style=color:#66d9ef>string</span> key, <span style=color:#66d9ef>int</span> defaultValue = <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StorageUtility</span> : IStorage
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> SaveInt(<span style=color:#66d9ef>string</span> key, <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>value</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            PlayerPrefs.SetInt(key, <span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> LoadInt(<span style=color:#66d9ef>string</span> key, <span style=color:#66d9ef>int</span> defaultValue = <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> PlayerPrefs.GetInt(key, defaultValue);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 引入 Command</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>IncreaseCountCommand</span> : AbstractCommand <span style=color:#75715e>// ++</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnExecute()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.GetModel&lt;CounterAppModel&gt;().Count.Value++;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DecreaseCountCommand</span> : AbstractCommand <span style=color:#75715e>// ++</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnExecute()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.GetModel&lt;CounterAppModel&gt;().Count.Value--;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Controller 实现 IController 接口</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CounterAppController</span> : MonoBehaviour, IController
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// View 组件</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Button BtnAdd;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Button BtnSub;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Text TxtCount;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Model</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> CounterAppModel model;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 获取 Model</span>
</span></span><span style=display:flex><span>            model = <span style=color:#66d9ef>this</span>.GetModel&lt;CounterAppModel&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            BtnAdd.onClick.AddListener(() =&gt;
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 交互逻辑</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.SendCommand&lt;IncreaseCountCommand&gt;();
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            BtnSub.onClick.AddListener(() =&gt;
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 交互逻辑</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span>.SendCommand(<span style=color:#66d9ef>new</span> DecreaseCountCommand(<span style=color:#75715e>/* 这里可以传参（如果有） */</span>));
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 表现逻辑</span>
</span></span><span style=display:flex><span>            model.Count.RegisterWithInitValue((newCount) =&gt;
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                UpdateView();
</span></span><span style=display:flex><span>            }).UnRegisterWhenGameObjectDestroyed(gameObject);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> UpdateView()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            TxtCount.text = model.Count.ToString();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 指定架构</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> IArchitecture GetArchitecture()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> CounterApp.Instance;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将 Model 设置为空</span>
</span></span><span style=display:flex><span>            model.OnDestroy();
</span></span><span style=display:flex><span>            model = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.GetSystem&lt;AchievementSystem&gt;().OnDestroy();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>所有的模块注册，模块获取 等代码都是通过接口完成，这一点符合 SOLID 原则中的 依赖倒置原则。</p><p>通过接口设计模块可以让我们更容易思考模块之间的交互和职责本身，而不是具体实现，在设计的时候可以减少很多的干扰。</p><h4 id=72-接口设计模块的好处>7.2 接口设计模块的好处
<a class=header-anchor href=#72-%e6%8e%a5%e5%8f%a3%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%9d%97%e7%9a%84%e5%a5%bd%e5%a4%84></a></h4><p>其中有一个很重要的一点就是，我们之前说的数据存储模块，如果想把存储的 API 从 PlayerPrefs 切换成 EasySave，那么我们就不需要去修改 Storage 对象，而是扩展一个 IStorage 接口即可，伪代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EasySaveStorage</span> : IStorage
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> SaveInt(<span style=color:#66d9ef>string</span> key, <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>value</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TODO</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> LoadInt(<span style=color:#66d9ef>string</span> key, <span style=color:#66d9ef>int</span> defaultValue = <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TODO</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注册模块的伪代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 定义一个架构（提供 MVC、分层、模块管理等）</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CounterApp</span> : Architecture&lt;CounterApp&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Configure()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 注册 System </span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.RegisterSystem&lt;IAchievementSystem&gt;(<span style=color:#66d9ef>new</span> AchievementSystem());
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 注册 Model</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.RegisterModel&lt;ICounterAppModel&gt;(<span style=color:#66d9ef>new</span> CounterAppModel());
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 注册存储工具的对象</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// this.RegisterUtility&lt;IStorage&gt;(new StorageUtility());</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.RegisterUtility&lt;IStorage&gt;(<span style=color:#66d9ef>new</span> EasySaveStorage());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样，<strong>底层所有存储的代码都切换成了 EasySave 的存储</strong>，替换一套方案非常简单。</p><h2 id=框架工具>框架工具
<a class=header-anchor href=#%e6%a1%86%e6%9e%b6%e5%b7%a5%e5%85%b7></a></h2><h3 id=1-单例模式singleton>1. 单例模式（Singleton）
<a class=header-anchor href=#1-%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8fsingleton></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 1.普通单例类</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestManager</span> : Singleton&lt;TestManager&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>//私有化构造函数</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> TestManager() { }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...Use...</span>
</span></span><span style=display:flex><span>TestManager.Instance
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#75715e>// 2.Mono 单例类</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[MonoSingletonPath(&#34;自定义路径：ToolKit/Test&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MonoScript</span> : MonoSingleton&lt;TestManager&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>                          
</span></span><span style=display:flex><span><span style=color:#75715e>// ...Use...</span>
</span></span><span style=display:flex><span>MonoScript.Instance
</span></span></code></pre></div><p>提供了 OnSingletonInit 方法，单例被创建时会被调用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 重写 OnSingletonInit</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnSingletonInit()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果需要更灵活的方法实现单例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#a6e22e>[MonoSingletonPath(&#34;[ToolKit]</span>/UIRoot<span style=color:#e6db74>&#34;)]
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UIKit</span> : MonoBehaviour, ISingleton
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> UIKit instance;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> UIKit Instance
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (instance == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Instantiate(Resources.Load&lt;GameObject&gt;(<span style=color:#e6db74>&#34;UIRoot&#34;</span>));
</span></span><span style=display:flex><span>                instance = SingletonCreator.CreateSingleton&lt;UIKit&gt;();
</span></span><span style=display:flex><span>                instance.name = <span style=color:#e6db74>&#34;UIRoot&#34;</span>;
</span></span><span style=display:flex><span>                DontDestroyOnLoad(instance);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> instance;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnSingletonInit() { }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        instance = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        Destroy(gameObject);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-事件系统event>2. 事件系统（Event）
<a class=header-anchor href=#2-%e4%ba%8b%e4%bb%b6%e7%b3%bb%e7%bb%9fevent></a></h3><h4 id=21-基础用法>2.1 基础用法
<a class=header-anchor href=#21-%e5%9f%ba%e7%a1%80%e7%94%a8%e6%b3%95></a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 定义结构体事件，需要继承 IEventData</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 最好是传入结构体，因为结构体比类的性能消耗要小</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TestEvent</span> : IEventData
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Message;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MonoScript</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 注册事件</span>
</span></span><span style=display:flex><span>        EventManager.Instance.Register&lt;TestEvent&gt;((eventData) =&gt;
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (eventData <span style=color:#66d9ef>is</span> TestEvent data)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Debug.Log(data.Message);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }).UnRegisterWhenGameObjectDestroyed(<span style=color:#66d9ef>this</span>); <span style=color:#75715e>// 自动注销事件</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 触发事件 可以传递数据</span>
</span></span><span style=display:flex><span>	    EventManager.Instance.Trigger&lt;TestEvent&gt;(<span style=color:#66d9ef>new</span> TestEvent()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Message = <span style=color:#e6db74>&#34;测试&#34;</span>,
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果不需要传递</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//EventManager.Instance.Trigger&lt;TestEvent&gt;();</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>一共提供了4种事件的自动注销方法：</p><ul><li><p>游戏对象被<strong>销毁</strong>时自动注销</p><ul><li>UnRegisterWhenGameObjectDestroyed</li><li>UnRegisterWhenGameObjectDestroyed<t></li></ul></li><li><p>游戏对象被<strong>失活</strong>时自动注销</p><ul><li>UnRegisterWhenDisabled</li><li>UnRegisterWhenDisabled<t></li></ul></li></ul><h4 id=22-如果需要手动注销事件>2.2 如果需要手动注销事件
<a class=header-anchor href=#22-%e5%a6%82%e6%9e%9c%e9%9c%80%e8%a6%81%e6%89%8b%e5%8a%a8%e6%b3%a8%e9%94%80%e4%ba%8b%e4%bb%b6></a></h4><p>需要创建一个方法来记录：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MonoScript</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TestEvent</span> : IEventData
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Message;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        EventManager.Instance.Register&lt;TestEvent&gt;(TestEventHandle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        EventManager.Instance.Trigger&lt;TestEvent&gt;(<span style=color:#66d9ef>new</span> TestEvent()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Message = <span style=color:#e6db74>&#34;Hello&#34;</span>,
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 手动注销事件</span>
</span></span><span style=display:flex><span>        EventManager.Instance.UnRegister&lt;TestEvent&gt;(TestEventHandle);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> TestEventHandle(IEventData eventData)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (eventData <span style=color:#66d9ef>is</span> TestEvent data)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Debug.Log(data.Message);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=23-简易事件系统easyevent>2.3 简易事件系统（EasyEvent）
<a class=header-anchor href=#23-%e7%ae%80%e6%98%93%e4%ba%8b%e4%bb%b6%e7%b3%bb%e7%bb%9feasyevent></a></h4><p>适合不需要做什么很复杂的操作时使用的事件。</p><p>简单使用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Input.GetKeyDown(KeyCode.A))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        EasyEventManager.Instance.Register&lt;<span style=color:#66d9ef>float</span>&gt;(<span style=color:#e6db74>&#34;Move&#34;</span>, Func);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Input.GetKeyDown(KeyCode.S))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        EasyEventManager.Instance.UnRegister&lt;<span style=color:#66d9ef>float</span>&gt;(<span style=color:#e6db74>&#34;Move&#34;</span>, Func);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Input.GetKeyDown(KeyCode.D))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        EasyEventManager.Instance.Trigger&lt;<span style=color:#66d9ef>float</span>&gt;(<span style=color:#e6db74>&#34;Move&#34;</span>, <span style=color:#ae81ff>0.5f</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Func(<span style=color:#66d9ef>float</span> f)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Debug.Log(<span style=color:#e6db74>&#34;Move &#34;</span> + f);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-对象池pool>3. 对象池（Pool）
<a class=header-anchor href=#3-%e5%af%b9%e8%b1%a1%e6%b1%a0pool></a></h3><h4 id=31-object-对象池>3.1 Object 对象池
<a class=header-anchor href=#31-object-%e5%af%b9%e8%b1%a1%e6%b1%a0></a></h4><p>提供给普通类对象使用的对象池。</p><p>实现 AudioTimer 对象：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 需要继承实现 IPoolObject 接口</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AudioTimer</span> : IPoolObject
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 这个可以不写，在外部调用也可以（对象池.Allocate()）</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> AudioTimer Allocate()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ObjectPool&lt;AudioTimer&gt;.Instance.Allocate();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> Recycle2Pool()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ObjectPool&lt;AudioTimer&gt;.Instance.Recycle(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnRecycled()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 被回收时逻辑</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>创建一个 AudioTimer 类对象的对象池：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 创建 AudioTimer 对象池</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> audioTimerPool = ObjectPool&lt;AudioTimer&gt;.Instance.Init(
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 预加载对象数量（可选，默认为 10）</span>
</span></span><span style=display:flex><span>    initialSize: <span style=color:#ae81ff>20</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 限制对象池最大数量（可选，默认为 -1 无限制）</span>
</span></span><span style=display:flex><span>    maxSize: <span style=color:#ae81ff>50</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 获取对象和回收对象 AudioTimer 对象的示例</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> timer = AudioTimer.Allocate();
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>( timer.Recycle() )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 返回 bool 值</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>支持自定义对象的创建和重置方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 默认的创建对象方式为 new</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// TODO</span>
</span></span></code></pre></div><h4 id=32-gameobject-对象池>3.2 GameObject 对象池
<a class=header-anchor href=#32-gameobject-%e5%af%b9%e8%b1%a1%e6%b1%a0></a></h4><p>专门提供给 GameObject 对象使用的对象池。</p><p>实现 Bullet 子弹对象：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Bullet</span> : MonoBehaviour, IPoolObject
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2s 后回收</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnEnable()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>	    Invoke(<span style=color:#e6db74>&#34;Recycle2Pool&#34;</span>, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> Recycle2Pool()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> GameObjectPoolManager.Instance.Recycle&lt;Bullet&gt;(<span style=color:#66d9ef>this</span>.gameObject);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnRecycled()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 被回收时逻辑</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>对象池获取 Bullet 对象：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Input.GetKeyDown(KeyCode.Space))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        GameObjectPoolManager.Instance.Allocate&lt;Bullet&gt;(<span style=color:#e6db74>&#34;资源加载名称&#34;</span>, (go) =&gt;
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Debug.Log(<span style=color:#e6db74>&#34;获取对象&#34;</span>);
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=33-对象池销毁>3.3 对象池销毁
<a class=header-anchor href=#33-%e5%af%b9%e8%b1%a1%e6%b1%a0%e9%94%80%e6%af%81></a></h4><p>由于对象池都是单例的，所以最后要做好销毁释放的问题：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// ObjectPool</span>
</span></span><span style=display:flex><span>audioTimerPool.OnDestroy();
</span></span><span style=display:flex><span>audioTimerPool = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// GameObjectPoolManager</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 1.销毁指定对象池</span>
</span></span><span style=display:flex><span>GameObjectPoolManager.Instance.DestroyPool&lt;Bullet&gt;();
</span></span><span style=display:flex><span><span style=color:#75715e>// 2.全部销毁，包括 GameObjectPoolManager 实例</span>
</span></span><span style=display:flex><span>GameObjectPoolManager.Instance.OnDestroy();
</span></span></code></pre></div><h3 id=4-计时器timer>4. 计时器（Timer）
<a class=header-anchor href=#4-%e8%ae%a1%e6%97%b6%e5%99%a8timer></a></h3><p>计时器通过 TimerManager 获取：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span>Timer timer = TimerManager.Instance.DeployTimer(
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>计时时间</span>, 
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>计时结束回调函数</span>, 
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>是否忽略缩放影响（可选）</span>,
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>是否循环计时（可选）</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>Timer 对外方法以及属性：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>暂停计时：</span>Pause();
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>继续计时：</span>Resum();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>是否完成：</span>IsCompleted
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>是否暂停：</span>IsPause
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>计时过去时间：</span>TimePassed
</span></span></code></pre></div><h3 id=5-音效系统audio>5. 音效系统（Audio）
<a class=header-anchor href=#5-%e9%9f%b3%e6%95%88%e7%b3%bb%e7%bb%9faudio></a></h3><p>播放背景音乐：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#></code></pre></div><p>播放人声（比如旁白、人物声音）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#></code></pre></div><p>播放游戏音效：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span>AudioManager.Instance.PlayerSound(
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>音源</span>, 
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>是否循环（可选）</span>,
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>音量大小（可选）</span>, 
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>播放结束回调函数（可选）</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h3 id=6-公共的-monobehaviourmono>6. 公共的 MonoBehaviour（Mono）
<a class=header-anchor href=#6-%e5%85%ac%e5%85%b1%e7%9a%84-monobehaviourmono></a></h3><p>公共 Mono 模块，让不继承 MonoBehaviour 的类也可以使用 Mono 的方法属性。</p><h4 id=61-帧更新事件>6.1 帧更新事件
<a class=header-anchor href=#61-%e5%b8%a7%e6%9b%b4%e6%96%b0%e4%ba%8b%e4%bb%b6></a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 添加</span>
</span></span><span style=display:flex><span>MonoManager.Instance.AddUpdateListener(UnityAction function);
</span></span><span style=display:flex><span><span style=color:#75715e>// 移除</span>
</span></span><span style=display:flex><span>MonoManager.Instance.RemoveUpdateListener(UnityAction function)
</span></span></code></pre></div><h4 id=62-让普通类能使用协程>6.2 让普通类能使用协程
<a class=header-anchor href=#62-%e8%ae%a9%e6%99%ae%e9%80%9a%e7%b1%bb%e8%83%bd%e4%bd%bf%e7%94%a8%e5%8d%8f%e7%a8%8b></a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span>MonoManager.Instance.StartCoroutine()
</span></span><span style=display:flex><span>MonoManager.Instance.StopCoroutine()
</span></span><span style=display:flex><span>MonoManager.Instance.StopAllCoroutines()
</span></span></code></pre></div><h4 id=63-mono-常用方法>6.3 Mono 常用方法
<a class=header-anchor href=#63-mono-%e5%b8%b8%e7%94%a8%e6%96%b9%e6%b3%95></a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#ae81ff>1.</span> <span style=color:#960050;background-color:#1e0010>创建</span> GmaeObject <span style=color:#960050;background-color:#1e0010>对象</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> GameObject NewGameObject(<span style=color:#66d9ef>string</span> name = <span style=color:#e6db74>&#34;NewGameObject&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2.</span> <span style=color:#960050;background-color:#1e0010>实例化</span> GameObject <span style=color:#960050;background-color:#1e0010>对象</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> GameObject InstantiateGameObject(GameObject go)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// TODO</span>
</span></span></code></pre></div><h3 id=7-资源加载工具集resloadkit>7. 资源加载工具集（ResLoadKit）
<a class=header-anchor href=#7-%e8%b5%84%e6%ba%90%e5%8a%a0%e8%bd%bd%e5%b7%a5%e5%85%b7%e9%9b%86resloadkit></a></h3><h4 id=71-启动资源加载管理器工具集>7.1 启动资源加载管理器工具集
<a class=header-anchor href=#71-%e5%90%af%e5%8a%a8%e8%b5%84%e6%ba%90%e5%8a%a0%e8%bd%bd%e7%ae%a1%e7%90%86%e5%99%a8%e5%b7%a5%e5%85%b7%e9%9b%86></a></h4><p>首先，这是必须的，建议放到游戏启动类中调用，会进行一些初始化操作，不然资源无法正确加载。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    AssetLoadKit.Instance.Boot();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=72-同步加载资源>7.2 同步加载资源
<a class=header-anchor href=#72-%e5%90%8c%e6%ad%a5%e5%8a%a0%e8%bd%bd%e8%b5%84%e6%ba%90></a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 1.同步加载：Type 指定类型</span>
</span></span><span style=display:flex><span>GameObject go = AssetLoadKit.Instance.LoadAsset(<span style=color:#e6db74>&#34;Bullet&#34;</span>, <span style=color:#66d9ef>typeof</span>(GameObject));
</span></span><span style=display:flex><span>Instantiate(obj);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2.同步加载：泛型</span>
</span></span><span style=display:flex><span>GameObject go = AssetLoadKit.Instance.LoadAsset&lt;GameObject&gt;(<span style=color:#e6db74>&#34;Bullet&#34;</span>);
</span></span></code></pre></div><h4 id=72-异步加载资源>7.2 异步加载资源
<a class=header-anchor href=#72-%e5%bc%82%e6%ad%a5%e5%8a%a0%e8%bd%bd%e8%b5%84%e6%ba%90></a></h4><p>关于 Addressables.MergeMode 可以看 Addressables 的介绍。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 异步加载：Type 指定类型</span>
</span></span><span style=display:flex><span>AssetLoadKit.Instance.LoadAssetAsync(<span style=color:#e6db74>&#34;Bullet&#34;</span>, <span style=color:#66d9ef>typeof</span>(GameObject), (res) =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Instantiate(obj);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 异步加载：泛型</span>
</span></span><span style=display:flex><span>AssetLoadKit.Instance.LoadAssetAsync&lt;GameObject&gt;(<span style=color:#e6db74>&#34;Bullet&#34;</span>, (res) =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Instantiate(obj);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h4 id=73-加载gameobjec对象自动实例化>7.3 加载GameObjec对象，自动实例化
<a class=header-anchor href=#73-%e5%8a%a0%e8%bd%bdgameobjec%e5%af%b9%e8%b1%a1%e8%87%aa%e5%8a%a8%e5%ae%9e%e4%be%8b%e5%8c%96></a></h4><p>方便加载 GameObjec 对象的方法，会自动实例化并返回：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 同步加载</span>
</span></span><span style=display:flex><span>GameObject go = AssetLoadKit.Instance.LoadGameObject(<span style=color:#e6db74>&#34;Bullet&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 异步加载</span>
</span></span><span style=display:flex><span>AssetLoadKit.Instance.LoadGameObjectAsync(<span style=color:#e6db74>&#34;Bullet&#34;</span>, (res) =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Debug.Log(res);
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><h4 id=73-资源释放>7.3 资源释放
<a class=header-anchor href=#73-%e8%b5%84%e6%ba%90%e9%87%8a%e6%94%be></a></h4><p>调用该函数卸载资源，会先计算引用计数，达到需求时会延迟卸载资源：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 目前只支持实机模式 TODO</span>
</span></span><span style=display:flex><span>AssetLoadKit.Instance.UnLoadAsset();
</span></span></code></pre></div><h3 id=8-数据存储datakit>8. 数据存储（DataKit）
<a class=header-anchor href=#8-%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8datakit></a></h3><h4 id=81-playerprefs>8.1 PlayerPrefs
<a class=header-anchor href=#81-playerprefs></a></h4><p>存储数据：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 参数一：数据字段 或 数据对象</span>
</span></span><span style=display:flex><span>DataKit.SavePlayerPrefsData(<span style=color:#66d9ef>object</span> data, <span style=color:#66d9ef>string</span> keyName);
</span></span></code></pre></div><p>读取数据：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 参数一：读取的数据类型</span>
</span></span><span style=display:flex><span>DataKit.LoadPlayerPrefsData(Type dataType, <span style=color:#66d9ef>string</span> keyName);
</span></span></code></pre></div><h4 id=82-json>8.2 Json
<a class=header-anchor href=#82-json></a></h4><p>存储数据：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 参数一：存储的类对象</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 参数二：Json 文件名</span>
</span></span><span style=display:flex><span>DataKit.SaveJsonData(<span style=color:#66d9ef>object</span> data, <span style=color:#66d9ef>string</span> fileName);
</span></span></code></pre></div><p>读取数据：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 参数一：读取路径 PersistentDataPath 或 StreamingAssetsPath 文件夹</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 游戏打包后需要存储到 PersistentDataPath 文件夹</span>
</span></span><span style=display:flex><span>DataKit.LoadJsonData&lt;T&gt;(<span style=color:#66d9ef>string</span> path);
</span></span></code></pre></div><h3 id=9-有限状态机fsm>9. 有限状态机（FSM）
<a class=header-anchor href=#9-%e6%9c%89%e9%99%90%e7%8a%b6%e6%80%81%e6%9c%bafsm></a></h3><h4 id=91-链式>9.1 链式
<a class=header-anchor href=#91-%e9%93%be%e5%bc%8f></a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建状态枚举</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>enum</span> States
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        AState,
</span></span><span style=display:flex><span>        BState
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建状态机</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> FSM&lt;States&gt; FSM = <span style=color:#66d9ef>new</span> FSM&lt;States&gt;();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建状态A链</span>
</span></span><span style=display:flex><span>        FSM.State(States.AState)
</span></span><span style=display:flex><span>            .OnCondition(() =&gt; FSM.CurrentStateId == States.BState)
</span></span><span style=display:flex><span>            .OnEnter(() =&gt; { Debug.Log(<span style=color:#e6db74>&#34;AState OnEnter&#34;</span>); })
</span></span><span style=display:flex><span>            .OnUpdate(() =&gt;
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(Input.GetKeyDown(KeyCode.Space))
</span></span><span style=display:flex><span>                    FSM.ChangeState(States.BState);
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .OnFixedUpdate(() =&gt; { })
</span></span><span style=display:flex><span>            .OnGUI(() =&gt; { })
</span></span><span style=display:flex><span>            .OnExit(() =&gt; { Debug.Log(<span style=color:#e6db74>&#34;BState OnEnter&#34;</span>); });
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建状态B链</span>
</span></span><span style=display:flex><span>        FSM.State(States.BState)
</span></span><span style=display:flex><span>            .OnCondition(() =&gt; FSM.CurrentStateId == States.AState)
</span></span><span style=display:flex><span>            .OnUpdate(() =&gt;
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(Input.GetKeyDown(KeyCode.Space))
</span></span><span style=display:flex><span>                    FSM.ChangeState(States.AState);
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 从状态A开始</span>
</span></span><span style=display:flex><span>        FSM.StartState(States.AState);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        FSM.Update();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> FixedUpdate()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        FSM.FixedUpdate();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnGUI()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        FSM.OnGUI();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        FSM.Clear();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=92-类模式>9.2 类模式
<a class=header-anchor href=#92-%e7%b1%bb%e6%a8%a1%e5%bc%8f></a></h4><p>链式适合在快速开发阶段，或者在状态非常少的阶段使用。</p><p>而如果状态较多，或者相应代码量较多的阶段，可以使用类模式，代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StateClassExample</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建状态枚举</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>enum</span> States
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        AState,
</span></span><span style=display:flex><span>        BState,
</span></span><span style=display:flex><span>        CState
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建状态机</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> FSM&lt;States&gt; FSM = <span style=color:#66d9ef>new</span> FSM&lt;States&gt;();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建状态A类</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StateA</span> : AbstractState&lt;States, StateClassExample&gt; <span style=color:#75715e>// States: 状态枚举, StateClassExample: 状态机类</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> StateA(FSM&lt;States&gt; fsm, StateClassExample target) : <span style=color:#66d9ef>base</span>(fsm, target)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>bool</span> OnCondition()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> fsm.CurrentStateId == States.BState;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnEnter()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Debug.Log(<span style=color:#e6db74>&#34;AState OnEnter&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnUpdate()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(Input.GetKeyDown(KeyCode.Space))
</span></span><span style=display:flex><span>                fsm.ChangeState(States.BState);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建状态B类</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StateB</span> : AbstractState&lt;States, StateClassExample&gt;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> StateB(FSM&lt;States&gt; fsm, StateClassExample target) : <span style=color:#66d9ef>base</span>(fsm, target)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>bool</span> OnCondition()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> fsm.CurrentStateId == States.AState;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnEnter()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Debug.Log(<span style=color:#e6db74>&#34;BState OnEnter&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> OnUpdate()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(Input.GetKeyDown(KeyCode.Space))
</span></span><span style=display:flex><span>                fsm.ChangeState(States.AState);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 状态机添加状态</span>
</span></span><span style=display:flex><span>        FSM.AddState(States.AState, <span style=color:#66d9ef>new</span> StateA(FSM, <span style=color:#66d9ef>this</span>));
</span></span><span style=display:flex><span>        FSM.AddState(States.BState, <span style=color:#66d9ef>new</span> StateB(FSM, <span style=color:#66d9ef>this</span>));
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 支持和链式模式混用</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// FSM.State(States.CState)</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//     .OnEnter(() =&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//     {</span>
</span></span><span style=display:flex><span>        //
</span></span><span style=display:flex><span>        <span style=color:#75715e>//     });</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 从状态A开始</span>
</span></span><span style=display:flex><span>        FSM.StartState(States.AState);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        FSM.Update();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> OnDestroy()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        FSM.Clear();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=10-ui-界面管理uikit>10. UI 界面管理（UIKit）
<a class=header-anchor href=#10-ui-%e7%95%8c%e9%9d%a2%e7%ae%a1%e7%90%86uikit></a></h3><h4 id=101-ui-代码自动生成>10.1 UI 代码自动生成
<a class=header-anchor href=#101-ui-%e4%bb%a3%e7%a0%81%e8%87%aa%e5%8a%a8%e7%94%9f%e6%88%90></a></h4><p>在 UI 面板 Inspector 窗口搜索添加脚本 CodeGen。</p><p>把需要的 UI 组件，拖进去，点击生成即可生成代码。</p><p>CodeGen 全局设置：在 CodeGenKitSetting 脚本可以更改。</p><p>注意：CodeGen 生成的 View 脚本是增量生成，和 Controller 脚本无关，即再次点击生成代码时只会改动 View 脚本，需要改动时可以放心生成。</p><h4 id=102-ui-面板管理>10.2 UI 面板管理
<a class=header-anchor href=#102-ui-%e9%9d%a2%e6%9d%bf%e7%ae%a1%e7%90%86></a></h4><p>UI 面板由 UIKit 统一管理，<strong>如果需要修改 Canvas，在 Project 搜索 UIRoot</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// EUILayer：UI 层级如果不设定，默认为 Middle</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 1. 打开面板</span>
</span></span><span style=display:flex><span>_ = UIKit.Instance.Open&lt;GamePanel&gt;(<span style=color:#e6db74>&#34;资源名&#34;</span>, (panel) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Logic</span>
</span></span><span style=display:flex><span>}, EUILayer.Middle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2. 关闭面板</span>
</span></span><span style=display:flex><span>UIKit.Instance.Close&lt;GamePanel&gt;(<span style=color:#e6db74>&#34;资源名&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 3. 销毁面板</span>
</span></span><span style=display:flex><span>UIKit.Instance.Destroy&lt;GamePanel&gt;(<span style=color:#e6db74>&#34;资源名&#34;</span>);
</span></span></code></pre></div><h4 id=103-ui-面板的生命周期自带方法>10.3 UI 面板的生命周期、自带方法
<a class=header-anchor href=#103-ui-%e9%9d%a2%e6%9d%bf%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e8%87%aa%e5%b8%a6%e6%96%b9%e6%b3%95></a></h4><p>生命周期：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 初始化，只调用一次</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnInit();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 每次打开都会调用</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnOpen();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 每次关闭都会调用</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnClose();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 面板被消耗时调用</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnPanelDestroy();
</span></span></code></pre></div><p>ViewController 自带方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>// 为控件添加自定义事件监听</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 比如可以给 Text 组件添加点击事件</span>
</span></span><span style=display:flex><span>AddCustomEventListener(<span style=color:#960050;background-color:#1e0010>控件对象</span>, <span style=color:#960050;background-color:#1e0010>事件类型</span>, <span style=color:#960050;background-color:#1e0010>事件的响应函数</span>);
</span></span></code></pre></div></div><footer class=post-footer><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
MRFramework</li><li class=post-copyright-author><strong>本文作者： </strong>醉雨非烟</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/post/mrframework/mrframework/ title=MRFramework>/post/mrframework/mrframework/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"></div><div class="post-nav-prev post-nav-item"><a href=/post/git-%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%E5%9B%9B%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/ rel=prev title="Git 入门到入土（四）一些操作汇总">Git 入门到入土（四）一些操作汇总
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2022 - 2023
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>醉雨非烟</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.120.4 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":true,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.5.3","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.0fb3547374c917d23a2e5f762b70f3698d20b46a01cc18c38f9c467aeffc99fc.js defer></script></body></html>